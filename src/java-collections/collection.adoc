= Collections Framework

[graphviz, align="center"]
----
digraph G {
  graph[bgcolor=transparent, color=grey]
  node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
  edge[color=white, fontcolor="white", fontname="Consolas"]
  
  Iterator
  Iterable
  Collection [color=green]
  List [color=green]
  Queue [color=green]
  Deque
  Set [color=green]
  SortedSet
  Map [color=green]
  SortedMap

  Comparable
  Comparator

  {Comparable, Comparator} -> SortedSet  [style=invis]
  {Comparable, Comparator} -> SortedMap  [style=invis]

  Collection -> Iterable
  {List, Queue, Set} -> Collection
  Deque -> Queue
  SortedSet -> Set
  SortedMap -> Map
  Iterator -> Iterable [label="iterator()", dir=back, style=dotted, color=grey, fontcolor=grey]

  Set -> Map [label="keys()", dir=back, style=dotted, color=grey, fontcolor=grey]
  Set -> Map [label="entrySet()", dir=back, style=dotted, color=grey, fontcolor=grey]
  Collection -> Map [label="values()", dir=back, style=dotted, color=grey, fontcolor=grey]
}
----

== Abstract implementations

[graphviz, align="center"]
----
digraph G {
  graph[bgcolor=transparent, color=grey]
  node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
  edge[color=white, fontcolor="white", fontname="Consolas"]
  
  Collection [color=gray, fontcolor=grey]
  List [color=gray, fontcolor=grey]
  Set [color=gray, fontcolor=grey]
  Queue [color=gray, fontcolor=grey]
  Map [color=gray, fontcolor=grey]

  List -> Collection [color=gray]
  Set -> Collection [color=gray]
  Queue -> Collection [color=gray]

  AbstractCollection -> Collection
  AbstractList -> {AbstractCollection, List}
  AbstractSequentialList -> AbstractList
  AbstractSet -> {AbstractCollection, Set}
  AbstractQueue -> {AbstractCollection, Queue}
  AbstractMap -> Map
}
----

== Collection Interface

[cols=3, frame=none, grid=none]
|===
a|
constructor
[source, java]
----
Collection()
Collection(Collection<? extends E> c)
----
misc
[source, java]
----
boolean equals(Object o)
int hashCode()
Object[] toArray()
<T> T[] toArray(T[] a)
----
a|
presence
[source, java]
----
boolean isEmpty()
boolean contains(Object o)
boolean containsAll(Collection<?> c)
----
traversal
[source, java]
----
Iterator<E> iterator()
----
a| 
insertion [Optional, may throw UnsupportedOperationException] 
[source, java]
----
boolean add(E e)
boolean addAll(Collection<? extends E> c)
----
removal [Optional, may throw UnsupportedOperationException]
[source, java]
----
void clear()
boolean remove(Object o)
boolean removeAll(Collection<? extends E> c)
boolean retainAll(Collection<? extends E> c)
----
|===

== Utility Interfaces

[plantuml, align="center"]
----
@startuml

skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old

interface Enumeration<E> {
    boolean hasMoreElements()
    E nextElement()
}

interface Iterator<E>  {
    boolean hasNext()
    E next()
    void remove()
}

interface Comparable<E>  {
    int compareTo(E e)
}

interface Comparator<E>  {
    int compare(E first, E second)
    --
    default Comparator<E> reversed()
    public static Comparator<E> comparing##(...)
    default Comparator<E> thenComparing##(...)
    --
    public static Comparator<E> nullsFirst(Comparator<E> comparator)
    public static Comparator<E> nullsLast(Comparator<E> comparator)
    public static Comparator<E> reverseOrder()
    public static Comparator<E> naturalOrder()
}
@enduml
----

== List

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface List<E>
interface RandomAccess
abstract AbstractList<E>
abstract AbstractSequentialList<E>
class LinkedList<E> #grey 
class ArrayList<E> #grey
class Arrays.asList<E> #grey
class CopyOnWriteArrayList<E> #grey
class SubList<E>
class RandomAccessSubList<E>

AbstractSequentialList --|> AbstractList
LinkedList --|> AbstractSequentialList
ArrayList --|> AbstractList
CopyOnWriteArrayList ..|> List
CopyOnWriteArrayList ..|> RandomAccess
ArrayList ..|> RandomAccess
SubList --|> AbstractList
RandomAccessSubList ..|> RandomAccess
RandomAccessSubList --|> SubList
Arrays.asList ..|> RandomAccess
Arrays.asList ..|> AbstractList
@enduml
----

=== List Interface

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface List<E>{
  void add(int index, E e)
  boolean addAll(int index, Collection<? extends E> c)
  --
  int indexOf(Object o)
  int lastIndexOf(Object o)
  E get(int index)
  E set(int index, E e)
  E remove(int index)
  --
  ListIterator<E> listIterator()
  ListIterator<E> listIterator(int indx)
  --
  List<E> subList(int fromIndex, int toIndex)
}

interface ListIterator<E> {
  boolean hasNext() // from Iterator<E>
  E next() // from Iterator<E>
  int nextIndex()
  --
  void set(E e)
  void add(E e)
  void remove() // from Iterator<E>
  --
  boolean hasPrevious()
  E previous()
  int previousIndex()  
}
@enduml
----

=== ArrayList

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent

participant User
create ArrayList
User -> ArrayList: new ArrayList()
create array
ArrayList -> array: new Object[10]
array --> ArrayList
ArrayList --> User

loop 10times
    User -> ArrayList: add(Object)
    ArrayList -> array: set(elementCount)
    array --> ArrayList
    ArrayList --> User
end

User -> ArrayList: add(Object)
note over ArrayList, array
    copy the  content of array into 
    another array twice the size
end note

ArrayList -> array: set(elementCount)
array --> ArrayList
ArrayList --> User
@enduml
----

=== LinkedList

[cols=2, frame=none, grid=none]
|===
a|[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface LinkedList<E>{
  void addFirst(E e)
  E getFirst()
  E removeFirst()
  --
  void addLast(E e)
  E getLast()
  E removeLast()
}

LinkedList ..\|> List
LinkedList ..\|> Deque
@enduml
----
a|[graphviz, align="center"]
----
digraph G{
    graph[bgcolor=transparent, rankdir=LR]
    node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
    edge[color=white, fontcolor="white", fontname="Consolas", tailclip=false]    

    item0 [label="<v>0\|<p>"]
    item1 [label="<v>1\|<p>"]
    item2 [label="<v>2\|<p>"]
    null [shape=none]

    item0:p:c -> item1:v
    item1:p:c -> item2:v
    item2:p:c -> null
}
----
|===

=== CopyOnWriteArrayList

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

class CopyOnWriteArrayList<E>{
  boolean addIfAbsent(int index, E e)
  int addAllAbsent(Collection< ? extends E>)
}
@enduml
----

=== Arrays.asList

[source, java]
----
class Application {
  public static void main(String[] args){
    Arrays.asList(1, 2, 3 ,4);
    List.of(1,2,3,4);
  }
}
----

== Set

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Set<E>
interface SortedSet<E>
interface NavigableSet<E>

abstract AbstractSet<E>
abstract EnumSet<E>

class HashSet<E> #grey 
class LinkedHashSet<E> #grey
class TreeSet<E> #grey
class CopyOnWriteArraySet<E> #grey
class ConcurrentSkipListSet<E>

SortedSet --|> Set
NavigableSet --|> SortedSet

AbstractSet ..|> Set
HashSet ..|> Set
LinkedHashSet ..|> Set
TreeSet ..|> NavigableSet
ConcurrentSkipListSet ..|> NavigableSet

EnumSet --|> AbstractSet
HashSet --|> AbstractSet
CopyOnWriteArraySet --|> AbstractSet
TreeSet --|> AbstractSet
ConcurrentSkipListSet --|> AbstractSet

LinkedHashSet --|> HashSet
@enduml
----

== Set Interfaces

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Collection<E>{
  boolean isEmpty()
  boolean contains(Object o)
  boolean containsAll(Collection<?> c)
  
  boolean add(E e)
  boolean addAll(Collection<? extends E> c)
  
  void clear()
  boolean remove(Object o)
  boolean removeAll(Collection<? extends E> c)
  boolean retainAll(Collection<? extends E> c)
}

interface Set<E>

interface SortedSet<E>{
  E first()
  E last()
  SortedSet headSet(E toElement)
  SortedSet tailSet(E fromElement)
  SortedSet subSet(E fromElement, E toElement)
  Comparator<? super E> comparator()
}

interface NavigableSet<E>{
  E ceiling(E e)
  E floor(E e)
  E higher(E e)
  E lower(E e)

  E pollFirst()
  E pollLast()
  
  NavigableSet<E> headSet(E toElement, boolean inclusive)
  NavigableSet<E> tailSet(E fromElement, boolean inclusive)

  NavigableSet<E> subSet(E from, boolean inclusive, E to, boolean inclusive)

  Iterator<E> descendingIterator()
  NavigableSet<E> descendingSet()
}

Collection <|- Set
Set <|- SortedSet
SortedSet <|- NavigableSet
@enduml
----

=== Generic Implementations

[cols=5]
|===
| Feature | HashSet | LinkedHashSet | TreeSet | EnumSet
| Keys Order | None | Fixed | Sorted| Sorted
| add() | O(1) | O(1) | O(log n)| O(1)
| contains() | O(1) | O(1) | O(log n)| O(1)
| next() | O(h/n) | O(1) | O(log n)| O(1)
|===

=== Concurrent Implementations

[cols=3]
|===
| Feature | CopyOnWriteArraySet | ConcurrentSkipListSet
| Keys Order | Fixed | Sorted 
| add() | O(n) | O(log n) 
| contains() | O(n) | O(log n) 
| next() | O(1) | O(1) 
|===

== Map

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Map<K, V>
interface SortedMap<K, V>
interface NavigableMap<K, V>
abstract AbstractMap<K, V>

interface ConcurrentMap<K, V>
interface ConcurrentNavigableMap<K, V>

class ConcurrentHashMap<K, V>
class ConcurrentSkipListMap<K, V>

class EnumMap<K, V>
class HashMap<K, V>
class LinkedHashMap<K, V>
class IdentityHashMap<K, V>
class WeakHashMap<E>
class TreeMap<E>

SortedMap --|> Map
NavigableMap --|> SortedMap
ConcurrentMap --|> Map
ConcurrentNavigableMap --|> NavigableMap
ConcurrentNavigableMap --|> ConcurrentMap

AbstractMap ..|> Map
ConcurrentHashMap ..|> ConcurrentMap
ConcurrentSkipListMap ..|> ConcurrentNavigableMap

AbstractMap <|-- EnumMap
AbstractMap <|-- HashMap
AbstractMap <|-- IdentityHashMap
WeakHashMap --|> AbstractMap
TreeMap --|> AbstractMap
ConcurrentHashMap --|> AbstractMap
ConcurrentSkipListMap --|> AbstractMap

LinkedHashMap --|> HashMap
@enduml
----

=== Map Interfaces

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Map<K, V>{
  boolean isEmpty()
  int size()

  boolean containsKey(Object)
  boolean containsValue(Object)
  
  V get(Object)
  V put(K key, V value)
  V putAll(Map<K, V> map)
  V remove(Object)
  void clear()

  Set<K> keySet()
  Collection<V> values()
  Set<Entry<K, V>> entrySet()  
}

interface SortedMap<K, V>{  
  K firstKey()
  K lastKey()

  SortedMap<K,V> headMap(K toKey)
  SortedMap<K, V> subMap(K fromKey, K toKey)
  SortedMap<K,V> tailMap(K fromKey)
}

interface NavigableMap<K, V>{
  NavigableSet<K> navigableKeySet()
  NavigableSet<K> descendingKeySet()
  NavigableMap<K,V> descendingMap()

  Map.Entry<K,V> firstEntry()
  Map.Entry<K,V> pollFirstEntry()
  Map.Entry<K,V> lastEntry()
  Map.Entry<K,V> pollLastEntry()

  K/Entry<K,V> ceilingKey/Entry(K key)
  K/Entry<K,V> floorKey/Entry(K key)
  K/Entry<K,V> higherKey/Entry(K key)
  K/Entry<K,V> lowerKey/Entry(K key)

  NavigableMap<K,V> headMap(K toKey, boolean inclusive)
  NavigableMap<K,V> subMap(K from, boolean inclusive, K to, boolean inclusive)
  NavigableMap<K,V> tailMap(K from, boolean inclusive)
}

interface ConcurrentMap<K, V>{
  V putIfAbsent(K key, V value)
  boolean remove(Object key, Object value)
  V replace(K key, V value)
  boolean replace(K key, V oldValue, V newValue)
}

Map <|- SortedMap
Map <|-- ConcurrentMap
SortedMap <|- NavigableMap
@enduml
----

=== Generic Implementations

[cols=5]
|===
| Feature       | HashMap | LinkedHashMap | TreeMap  | EnumMap
| Keys Order    | None    | Fixed         | Sorted   | Sorted
| get()         | O(1)    | O(1)          | O(log n) | O(1)
| containsKey() | O(1)    | O(1)          | O(log n) | O(1)
| next()        | O(h/n)  | O(1)          | O(log n) | O(1)
|===

=== Concurrent Implementations

[cols=3]
|===
| Feature       | ConcurrentHashMap | ConcurrentSkipListMap
| Keys Order    | None              | Sorted                
| get()         | O(1)              | O(log n)                 
| containsKey() | O(1)              | O(log n)                
| next()        | O(h/n)            | O(1)                 
|===

=== Specific Implementations

[graphviz, align="center"]
----
digraph G{
    graph[bgcolor=transparent, rankdir=LR]
    node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
    edge[color=white, fontcolor="white", fontname="Consolas", tailclip=false]    

    WeakHashMap
    IdentityHashMap
    LinkedHashMap
}
----

== Queue

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Queue<E>
interface Deque<E>
interface BlockingQueue<E>
interface BlockingDeque<E>
interface TransferQueue<E>

abstract AbstractQueue<E>

class LinkedList<E>
class ArrayDeque<E>
class ConcurrentLinkedQueue<E>
class PriorityBlockingQueue<E>
class PriorityQueue<E>
class ArrayBlockingQueue<E>
class LinkedTransferQueue<E>
class DelayQueue<E>
class LinkedBlockingQueue<E>
class SynchronousQueue<E>
@enduml
----

=== Queue Interface

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface Collection<E>{
  boolean add(E o) //throws
}

interface Queue<E>{
  boolean offer(E o)

  E element() //throws
  E peek()
  
  E remove() //throws
  E poll()
}

interface TransferQueue<E>{  
  int getWaitingConsumerCount()
  boolean hasWaitingConsumer()
  void transfer(E e)
  boolean tryTransfer(E e)
  boolean tryTransfer(E e, long timeout, TimeUnit unit)
}

interface Deque<K, V>{
  void addFirst/Last(E e)
  boolean offerFirst/Last(E e)
  E peekFirst/Last()
  E pollFirst/Last()
  E getFirst/Last()
  E removeFirst/Last()
  void push(E e)
  E pop()
}

interface BlockingQueue<K, V>{
  int drainTo(Collection< ? super E> c)
  int drainTo(Collection < ? super E> c, int maxElements)
  int remainingCapacity()
  E take()
}

interface BlockingDeque<K, V>{
}
Collection <|- Queue
Queue <|-- Deque
Queue <|- BlockingQueue
BlockingQueue <|-- TransferQueue
Deque <|-- BlockingDeque
BlockingQueue <|-- BlockingDeque

@enduml
----

=== Specific Implementations

----
digraph G{
    graph[bgcolor=transparent, rankdir=LR]
    node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
    edge[color=white, fontcolor="white", fontname="Consolas"]    

    SynchronousQueue
    Delayed
    BlockingQueue [color=gray, fontcolor=grey]
    SynchronousQueue -> BlockingQueue
    DelayQueue -> BlockingQueue  [color=gray]
    DelayQueue -> Delayed  [color=gray, style=dotted]
}
----

=== Specific Implementations

[graphviz, align="center"]
----
digraph G{
    graph[bgcolor=transparent, rankdir=LR]
    node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
    edge[color=white, fontcolor="white", fontname="Consolas"]    

    "Array based"
    "Link-based"
    "Priority based"
}
----

== Collections Algorithms

[cols=5, frame=none, grid=none]
|===
a|
[source, java]
----
sort
binarySearch
reverse
reverseOrder
----
a|
[source, java]
----
shuffle
swap
rotate
----
a|
[source, java]
----
fill
copy
----
a|
[source, java]
----
replaceAll
----
a|
[source, java]
----
min
max
----
a|
[source, java]
----
indexOfSubList
lastIndexOfSubList
----
a|
[source, java]
----
unmodifiable__
synchronized__
checked__
----
a|
[source, java]
----
empty__
singleton__
nCopies
----
a|
[source, java]
----
enumeration
list
----
a|
[source, java]
----
frequency
disjoint
addAll
newSetFromMap
asLifoQueue
----
|===

