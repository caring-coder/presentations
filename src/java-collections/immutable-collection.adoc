= Collections Framework

[graphviz, align="center"]
----
digraph G {
  graph[bgcolor=transparent, color=grey]
  node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
  edge[color=white, fontcolor="white", fontname="Consolas"]
  
  Iterator
  Iterable
  Collection [color=green]
  List [color=green]
  Queue [color=green]
  Deque
  Set [color=green]
  SortedSet
  Map [color=green]
  SortedMap

  Comparable
  Comparator

  {Comparable, Comparator} -> SortedSet  [style=invis]
  {Comparable, Comparator} -> SortedMap  [style=invis]

  Collection -> Iterable
  {List, Queue, Set} -> Collection
  Deque -> Queue
  SortedSet -> Set
  SortedMap -> Map
  Iterator -> Iterable [label="iterator()", dir=back, style=dotted, color=grey, fontcolor=grey]

  Set -> Map [label="keys()", dir=back, style=dotted, color=grey, fontcolor=grey]
  Set -> Map [label="entrySet()", dir=back, style=dotted, color=grey, fontcolor=grey]
  Collection -> Map [label="values()", dir=back, style=dotted, color=grey, fontcolor=grey]
}
----

== Abstract implementations

[graphviz, align="center"]
----
digraph G {
  graph[bgcolor=transparent, color=grey]
  node[shape=record, color=white, fontcolor=white, fontname="Consolas"]
  edge[color=white, fontcolor="white", fontname="Consolas"]
  
  Collection [color=gray, fontcolor=grey]
  List [color=gray, fontcolor=grey]
  Set [color=gray, fontcolor=grey]
  Queue [color=gray, fontcolor=grey]
  Map [color=gray, fontcolor=grey]

  List -> Collection [color=gray]
  Set -> Collection [color=gray]
  Queue -> Collection [color=gray]

  AbstractCollection -> Collection
  AbstractList -> {AbstractCollection, List}
  AbstractSequentialList -> AbstractList
  AbstractSet -> {AbstractCollection, Set}
  AbstractQueue -> {AbstractCollection, Queue}
  AbstractMap -> Map
}
----

== Collection Interface

|===
| constructor | traverse
a|
[source, java]
----
Collection()
Collection(Collection<? extends E> c)
----
a|
[source, java]
----
boolean equals(Object o)
int hashCode()
Object[] toArray()
<T> T[] toArray(T[] a)
----
| presence | traverse
a|
[source, java]
----
boolean isEmpty()
boolean contains(Object o)
boolean containsAll(Collection<?> c)
----
a|
[source, java]
----
Iterator<E> iterator()
----
| add [Optional, may throw UnsupportedOperationException] |  remove [Optional, may throw UnsupportedOperationException] 
a|
[source, java]
----
boolean add(E e)
boolean addAll(Collection<? extends E> c)
----
a|
[source, java]
----
void clear()
boolean remove(Object o)
boolean removeAll(Collection<? extends E> c)
boolean retainAll(Collection<? extends E> c)
----
|===

== Iterator

[plantuml, align="center"]
----
@startuml

skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old

interface Enumeration<E> {
    boolean hasMoreElements()
    E nextElement()
}

interface Iterator<E>  {
    boolean hasNext()
    E next()
    void remove()
}
@enduml
----

== List

[plantuml, align="center"]
----
@startuml
skinparam monochrome reverse
skinparam handwritten true
skinparam BackgroundColor transparent
skinparam genericDisplay old
set namespaceSeparator none

interface List<E>
interface RandomAccess
abstract AbstractList<E>
abstract AbstractSequentialList<E>
class LinkedList<E> #grey 
class ArrayList<E> #grey
class Arrays.asList<E> #grey
class CopyOnWriteArrayList<E> #grey
class SubList<E>
class RandomAccessSubList<E>

AbstractSequentialList --|> AbstractList
LinkedList --|> AbstractSequentialList
ArrayList --|> AbstractList
CopyOnWriteArrayList ..|> List
CopyOnWriteArrayList ..|> RandomAccess
ArrayList ..|> RandomAccess
SubList --|> AbstractList
RandomAccessSubList ..|> RandomAccess
RandomAccessSubList --|> SubList
Arrays.asList ..|> RandomAccess
Arrays.asList ..|> AbstractList
@enduml
----

== Set

=== SortedSet

=== NavigableSet

== Map

== Sorted Map

== Navigable Map

== Queue

=== Deque

